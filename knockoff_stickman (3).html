<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Knock-Off Stickman — Single File Game</title>
  <style>
    :root{--bg:#0f172a;--ground:#0b1220;--accent:#ffd166;--muted:#94a3b8}
    *{box-sizing:border-box;font-family:Inter, system-ui, -apple-system, sans-serif}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071023);color:#e6eef8}
    .wrap{display:flex;flex-direction:column;min-height:100vh;align-items:center;padding:18px}
    header{width:100%;max-width:1000px;margin-bottom:10px;text-align:center}
    h1{margin:6px 0;font-size:20px}
    p.lead{margin:0;color:var(--muted)}
    .game-area{position:relative;width:100%;max-width:1000px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    canvas{display:block;width:100%;height:480px;border-radius:8px;background:linear-gradient(180deg,#0b1226 0%, #041026 100%);}
    .game-over{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:48px;font-weight:800;color:#ffd166;text-shadow:0 0 10px rgba(0,0,0,0.8);display:none;}
    footer{margin-top:10px;display:flex;gap:8px;align-items:center;justify-content:space-between}
    .controls{display:flex;gap:8px;align-items:center}
    button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:#041022;font-weight:700;cursor:pointer}
    .info{color:var(--muted);font-size:13px}
    .hud{display:flex;gap:12px;align-items:center}
    .pill{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:10px;color:var(--muted);font-size:14px}
    .small{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Knock-Off Stickman</h1>
      <p class="lead">Fight endless waves of stickman enemies. Move, jump, and punch to survive!</p>
    </header>

    <div class="game-area">
      <canvas id="game" width="1000" height="480"></canvas>
      <div id="gameOver" class="game-over">GAME OVER</div>
      <div style="display:flex;justify-content:space-between;margin-top:8px;align-items:center;">
        <div class="hud">
          <div class="pill">Score: <span id="score">0</span></div>
          <div class="pill">Lives: <span id="lives">3</span></div>
        </div>
        <div class="controls">
          <button id="startBtn">Start / Restart</button>
          <div class="info small">Controls: ← → = Move • Space = Jump • Z = Punch</div>
        </div>
      </div>
    </div>

    <footer style="width:100%;max-width:1000px;margin-top:12px">
      <div class="small">Made with pure HTML (single file: HTML + CSS + JS). No libraries.</div>
    </footer>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const startBtn = document.getElementById('startBtn');
  const gameOverEl = document.getElementById('gameOver');

  const W = canvas.width;
  const H = canvas.height;
  const groundY = H - 70;

  let state = {
    running: false,
    score: 0,
    lives: 3,
    player: null,
    enemies: [],
    keys: {},
    lastSpawn: 0,
    spawnInterval: 1200,
    lastTime: 0
  };

  function createPlayer(){
    return {
      x: 140,
      y: groundY - 60,
      vx: 0,
      vy: 0,
      w: 20,
      h: 60,
      onGround: true,
      facing: 1,
      attacking: false,
      attackTimer: 0
    };
  }

  function spawnEnemy(){
    const side = Math.random()<0.5?-1:1;
    const x = side < 0 ? -40 : W + 40;
    const vx = (2 + Math.random()*1.5) * (side < 0 ? 1 : -1);
    return { x, y: groundY-60, vx, vy:0, knocked:false, knockTimer:0 };
  }

  function reset(){
    state.running = true;
    state.score = 0;
    state.lives = 3;
    state.player = createPlayer();
    state.enemies = [];
    state.lastSpawn = 0;
    state.spawnInterval = 1200;
    state.lastTime = performance.now();
    updateHUD();
    gameOverEl.style.display = 'none';
    requestAnimationFrame(loop);
  }

  function updateHUD(){
    scoreEl.textContent = state.score;
    livesEl.textContent = state.lives;
  }

  window.addEventListener('keydown', e => {
    if(["Space","ArrowUp","ArrowLeft","ArrowRight","KeyZ"].includes(e.code)) e.preventDefault();
    state.keys[e.code] = true;
  });
  window.addEventListener('keyup', e => {
    if(["Space","ArrowUp","ArrowLeft","ArrowRight","KeyZ"].includes(e.code)) e.preventDefault();
    state.keys[e.code] = false;
  });

  startBtn.addEventListener('click', reset);

  function loop(ts){
    if(!state.running) return;
    const dt = Math.min(40, ts - state.lastTime);
    state.lastTime = ts;

    state.lastSpawn += dt;
    if(state.lastSpawn > state.spawnInterval){
      state.lastSpawn = 0;
      state.enemies.push(spawnEnemy());
      state.spawnInterval = Math.max(500, state.spawnInterval - 20);
    }

    update(dt/16.6667);
    render();
    requestAnimationFrame(loop);
  }

  function update(delta){
    const p = state.player;
    if(!p) return;

    const speed = 3;
    if(state.keys['ArrowLeft']){ p.vx = -speed; p.facing = -1; }
    else if(state.keys['ArrowRight']){ p.vx = speed; p.facing = 1; }
    else p.vx = 0;

    if((state.keys['Space'] || state.keys['ArrowUp']) && p.onGround){
      p.vy = -11; p.onGround = false;
    }

    if(state.keys['KeyZ'] && !p.attacking){
      p.attacking = true; p.attackTimer = 12;
    }
    if(p.attacking){ p.attackTimer -= delta; if(p.attackTimer<=0) p.attacking=false; }

    p.vy += 0.6 * delta;
    p.x += p.vx * delta;
    p.y += p.vy * delta;
    if(p.y + p.h >= groundY){ p.y = groundY - p.h; p.vy = 0; p.onGround = true; }
    p.x = Math.max(20, Math.min(W-40, p.x));

    for(let i = state.enemies.length-1; i>=0; i--){
      const e = state.enemies[i];
      if(e.knocked){
        e.vy += 0.5 * delta;
        e.x += e.vx * delta;
        e.y += e.vy * delta;
        e.knockTimer -= delta;
        if(e.y > H + 80 || e.knockTimer <= 0){ state.enemies.splice(i,1); }
        continue;
      }
      e.x += e.vx * delta;
      if(rectCollide(p.x,p.y,p.w,p.h,e.x-10,e.y-40,20,60)){
        if(p.attacking){
          e.knocked = true;
          e.knockTimer = 120;
          e.vy = -9;
          e.vx = (e.x < p.x ? -5 : 5);
          state.score += 100;
          updateHUD();
        } else {
          state.lives--;
          updateHUD();
          state.enemies.splice(i,1);
          if(state.lives <= 0){
            state.running = false;
            gameOverEl.style.display = 'block';
            return;
          }
        }
      }
      if(e.x < -100 || e.x > W+100){ state.enemies.splice(i,1); }
    }
  }

  function rectCollide(x1,y1,w1,h1,x2,y2,w2,h2){
    return x1 < x2+w2 && x1+w1 > x2 && y1 < y2+h2 && y1+h1 > y2;
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#081427';
    ctx.fillRect(0, groundY, W, H-groundY);

    const p = state.player;
    if(p) drawStickman(p.x, p.y, p.facing, p.attacking);

    state.enemies.forEach(e => drawStickmanEnemy(e.x,e.y,e.knocked));
  }

  function drawStickman(x,y,facing,attacking){
    ctx.strokeStyle = '#e6eef8';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(x, y-40, 12, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y-28); ctx.lineTo(x, y+20); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y-20); ctx.lineTo(x+facing*20, y-5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y-20); ctx.lineTo(x-facing*20, y-5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y+20); ctx.lineTo(x-15, y+45); ctx.moveTo(x, y+20); ctx.lineTo(x+15, y+45); ctx.stroke();
    if(attacking){
      ctx.strokeStyle = '#ffd166';
      ctx.beginPath(); ctx.arc(x+facing*30,y-5,10,0,Math.PI*2); ctx.stroke();
    }
  }

  function drawStickmanEnemy(x,y,knocked){
    ctx.strokeStyle = knocked ? 'red' : '#00ffaa';
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.arc(x, y-40, 12, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y-28); ctx.lineTo(x, y+20); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y-20); ctx.lineTo(x+20, y-5); ctx.moveTo(x, y-20); ctx.lineTo(x-20, y-5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y+20); ctx.lineTo(x-15, y+45); ctx.moveTo(x, y+20); ctx.lineTo(x+15, y+45); ctx.stroke();
  }
})();
</script>
</body>
</html>